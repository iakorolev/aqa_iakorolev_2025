В файле `main.py` я указываю путь к входному XML-файлу с UML-моделью, затем запускаю парсер, который преобразует эту модель в структуру данных. После этого структура передается двум генераторам: один создаёт `config.xml` с иерархией классов, другой — `meta.json` с описанием всех классов и их параметров. Все результаты сохраняются в папку `out`.

`parser.py` - это парсер, который читает входной XML-файл с UML-моделью. Сначала он находит все описанные в файле классы и создаёт для каждого отдельный объект, где сохраняются его имя, описание, флаг того, является ли он корневым, а также список атрибутов. Затем обрабатываются связи между классами (агрегации), чтобы понять, какие классы вложены друг в друга, и устанавливаются кратности (минимальное и максимальное количество вхождений). В итоге получается словарь всех классов.

`make.py` необходим для генерации выходных файлов `config.xml` и `meta.json`. Класс `ConfigGen` создаёт файл `config.xml`, в котором формируется иерархическая структура классов начиная с корневого, где каждый класс представлен в виде XML-элемента с вложенными дочерними. Класс `MetaGen` создаёт файл `meta.json`, где для каждого класса указывается его имя, описание, флаг корневого, параметры (атрибуты и дочерние классы), а также минимальная и максимальная кратность. Чтобы классы шли в правильном порядке — от независимых к корневому — я использовал топологическую сортировку.


# Структура проекта

```
├── main.py            # Точка входа: парсит XML, генерирует артефакты
├── parser.py          # XML-парсер, извлекающий модель классов и связей
├── make.py            # Генерация config.xml и meta.json
├── out/               # Папка для вывода артефактов
└── test_input.xml     # Пример входного файла UML
```

## Использование

```bash
python main.py
```

После запуска в папке `out/` появятся два файла:

* `config.xml`
* `meta.json`
