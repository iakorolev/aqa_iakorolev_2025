В файле `main.py` я указываю путь к входному XML-файлу с UML-моделью, затем запускаю парсер, который преобразует эту модель в структуру данных. После этого структура передается двум генераторам: один создаёт `config.xml` с иерархией классов, другой — `meta.json` с описанием всех классов и их параметров. Все результаты сохраняются в папку `out`.

`parser.py` - это парсер, который читает входной XML-файл с UML-моделью. Использую стандартную библиотеку xml.etree.ElementTree для чтения и обхода XML-структуры. Сначала ищутся все элементы `<Class>`, описанные в файле, и для каждого создаёт объект с нужной информацией: именем, описанием, флагом `isRoot`, списком атрибутов. Затем обрабатываются элементы `<Aggregation>`, чтобы установить связи между классами — кто кому "дочерний", кто "родитель", и сколько раз один класс может включать другой (кратность).
В итоге формируется словарь, где ключи — это имена классов, а значения — объекты с полной информацией о каждом классе и его связях. Этот словарь затем используется для генерации выходных файлов.

`make.py`запускает генерацию выходных файлов на основе распарсенной UML-модели. В классе `ConfigGen` строится иерархический XML-документ: сначала находится корневой класс, затем по модели рекурсивно создаются вложенные элементы и атрибуты, а результат сохраняется в красиво отформатированном виде. Класс `MetaGen` формирует JSON-описание всех классов: включает информацию об именах, описаниях, параметрах, кратностях и сохраняет это в отдельный файл.

# Структура проекта

```
├── main.py            # Точка входа: парсит XML, генерирует артефакты
├── parser.py          # XML-парсер, извлекающий модель классов и связей
├── make.py            # Генерация config.xml и meta.json
├── out/               # Папка для вывода артефактов
└── test_input.xml     # Пример входного файла UML
```

## Использование

```bash
python main.py
```

После запуска в папке `out/` появятся два файла:

* `config.xml`
* `meta.json`
